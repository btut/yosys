# Adding functionality to pyosys

For a yosys class or function to be exposed to python we create wrappers around
them.
This is to separate yosys' core functionality from pyosys and to allow different
types of links between yosys C++ and python objects.
To keep the wrappers synched with the C++ source, the wrappers are generated by
a python script (misc/py_wrap_generator.py) on each build.

The py_wrap_generator script parses a subset of yosys' C++ header files for
structures to be exposed to python.
To make sure the pyosys library is working fine this subset was carefully
selected.
However, users may find themselves in need for a class or function that was not
exposed by the py_wrap_generator script.
Those users are in luck, as the needed functionalities can easily be included
in the automatic generation of wrappers.

The py_wrap_generator script contains a list of sources to parse.
You can find it below the following comment:

`#CONFIGURE HEADER-FILES TO BE PARSED AND CLASSES EXPECTED IN THEM HERE`

A source is made up of the name of a header file and the classes that are to be
exposed.
The script automatically creates wrappers for static variables and functions
found in the header file and for classes that are mentioned.
There are a few restrictions on what can be wrapped though.

In order for the script to expose a variable or function, all types must be
known by the script.
These types are:
- primitive types as supported by boost::python: void, bool, int, double,
	size_t, string, State, char_p
- wrapped types: all types that the py_wrap_generator generates wrappers for
- certain containers that contain only the types mentioned above.
	Currently, pyosys supports std::set, std::vector, pool, idict, dict,
	std::pair and std::map. All of them are mapped either to python lists or
	dicts

If the needed functionality makes use of other types, those types must be
wrapped around as well.
For yosys types, this can be done by adding them to the sources-list as well.
Adding other container types is detailed later on in this document.

For now, let's focus on how to wrap additional yosys types.

1. check if there are any dependencies (missing types) needed.
	If there are, wrap around those dependencies by following these steps
	for each dependency.
1. check if any new container-types are used.
	If so, add them to pyosys by following the steps at the end of this
	document.
1. check if the source file that contains the needed functionalities is already
	listed.
	If not, add it.
	If you only want to add static functions or variables, you are already done,
	move on to the last step in this list
1. add the classes you need.
	Classes to be wrapped are described as WClass objects.
	It's constructor expects 6 parameters that are described here:
	- name
	- link_type: this describes how the C++ and python objects are linked.
		A guideline to which type to use when is given later in this document.
	- id_ a uniqe identifier.
		This is only relevant for classes that are wrapped using a global list
	- string_id: The function to be called when converting the object to a
		string.
		This can be "none" if there is no suitable function
	- hash_id: The function that should be matched to pythons `hash` function.
	- needs_clone: This is only needed for classes wrapped by ref_copy.
		If it is set, the classes clone function is called, otherwise the
		copy-constructor is used.
1. build the library

## LINK TYPES

There are four possible ways to link python objects to their C++ counterparts.

1. global_list: a global map is created storing all objects of that type.
	For this to work, each object needs to be identifiable so there is a value
	to use as a key.
	The python object will then only store that key.
	For each call to that object, a lookup is performed in the global list to
	find the corresponding C++ object to work on.
1. ref_copy: the python object stores a copy of the C++ object
1. pointer: the python object contains a pointer to it's C++ counterpart
1. derive: the python wrapper-class is derived from the C++ object

## CONTAINERS

To add new containers to pyosys, one needs to add to the known_containers list
and create a translator between the C++ container and the python container.

A translator is made up of three functions:

- gen_type generates the C++ type string
- translate generates the translation code from python to C++
- translate_cpp generate the translation code from C++ to python

If the needed type will be translated to a python list or dict, chances are the
code needed is very similar for other C++ types that translate into those
containers.
If that is the case, one can only adapt those classes minimally to achieve
working results.
This can be seen in the translators for IDict, Set, Vector, Pool, Dict and Map.
All that needs to be adapted is the name of the C++ type as well as the method
that is used to add elements to that type.

For more complicated types, one can check the TupleTranslator for inspiration.
